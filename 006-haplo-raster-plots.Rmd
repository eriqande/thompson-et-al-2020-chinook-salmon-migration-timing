---
title: "Haplo-raster Plots"
author: "Eric C. Anderson"
date: "Last Updated: `r Sys.Date()`"
output: 
  html_document:
    df_print: paged
    toc: true
    toc_float: true
bibliography: references.bib
---


Here we produce the haplo-raster plots.  One with the alleles and the other with the read
depths in each fish.  


```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
start_time <- Sys.time()
```

# Packages and paths 
```{r}
library(tidyverse)
library(ecaRbioinf) # will put on github eventually


dir.create("outputs/006", recursive = TRUE, showWarnings = FALSE)
dir.create("intermediates/006", recursive = TRUE, showWarnings = FALSE)
```

# Load up needed data from previous steps

Grab the big_haps2.rds from the 004 notebook, and also the Johnson Creek fish.
Choose here whether to use the stored big_haps (that we used) or others
generated by BEAGLE that might be subtly different.  In this works
there is little difference, but, because BEAGLE randomly imputes and phases
things, if you want to get a figure that looks just like the one
we produced, you will want to use the stored results from 004.


```{r}
USE_STORED_BIG_HAPS <- FALSE

if(USE_STORED_BIG_HAPS != TRUE) {
  big_haps2 <- read_rds(path = "outputs/004/big_haps2.rds")
  jc_fish <- read_rds(path = "outputs/004/jc_fish_haps.rds")
  
  # Make a data frame with everyone, Johnson Creek included:
  big_haps2_jc <- bind_rows(big_haps2, jc_fish)
} else {
  big_haps2 <- read_rds("stored_results/004/big_haps2.rds")
  big_haps2_jc <- read_rds("stored_results/004/big_haps2_with_jc.rds")
}

haps_fix <- read_rds(path = "outputs/004/big_haps2_fixed_info.rds")

```

# First compile auxiliary genome features

Here we get data that is used for the annotation rows below the rasters.

## Whether snps are in genes, exons, CDSs...

Intersect the gff file with the variants, after whittling it down to one individual
```{sh}
bcftools view -s DPCh_plate1_A01_S1  data/greb1l-ish-region.vcf.gz -Oz > intermediates/006/one-sample-vcf-greb1l-ish.vcf.gz

bedtools intersect -a intermediates/006/one-sample-vcf-greb1l-ish.vcf.gz  -b genome/GCF_002872995.1_Otsh_v1.0_genomic.gff.gz -wb > intermediates/006/variant-annotations.tsv
```
Then read that into a tibble
```{r}
snp_anno <- read_tsv("intermediates/006/variant-annotations.tsv",
                     col_names = c(
                       "CHROM", 
                       "POS",
                       "dot1",
                       "REF",
                       "ALT",
                       "VSCORE",
                       "dot2",
                       "dot3",
                       "format",
                       "a_sample",
                       "CHROM2",
                       "method",
                       "what",
                       "start",
                       "stop",
                       "dot4",
                       "strand",
                       "phase",
                       "biggie"
                     ))

# look at what we have here
snp_anno %>%
  count(what)



```

So, for a quick visualization, I am first going to classify
sites as belonging to genes, pseudo-genes, or non-genes.  

Subsequently, I will classify things within genes as exon, CDS, or other.
```{r}
gene_stuff_func <- function(what) {
    if(any(what == "gene")) {
      ret <- "gene";
    } else if (any(what == "pseudogene")) {
      ret <- "pseudogene"
    } else {
      ret <- "non-gene"
    }
  ret
}
gene_stuff <- snp_anno %>%
  group_by(CHROM, POS) %>%
  summarise(ginc = gene_stuff_func(what))

exon_stuff_func <- function(what) {
  if(any(what == "CDS")) {
      ret <- "CDS";
    } else if (any(what == "exon")) {
      ret <- "exon"
    } else {
      ret <- "non-exon"
    }
  ret
}

# define exon_stuff only for things found in genes
exon_stuff <- snp_anno %>%
  semi_join(gene_stuff %>% filter(ginc == "gene"), by = c("CHROM", "POS")) %>%
  group_by(CHROM, POS) %>%
  summarise(einc = exon_stuff_func(what))
  
```

## Codon position of the SNPs that are in coding seqeunces

We use snpEff's designation of synonymous or missense.
I will just define things that are missense as `codon_pos1` and synonymous ones as `codon_pos3`.  I am
doing this because I am pretty sure that the haplo raster function is hard-wired to use those designations,
rather than synonymous/missense. 

First, get the SNPs in CDS
```{r}
cds_snps <- snp_anno %>% 
  filter(what == "CDS")
```

```{r}
# read it in
snpeff <- read_rds("outputs/005/variants-and-annos-5.16.rds")

# only retain positions that are MODERATE or HIGH (this kicks out the synonymous ones)
HiMod <- snpeff %>%
  filter(snp_eff_effect %in% c("MODERATE", "HIGH")) %>%
  select(CHROM, POS, snp_eff_effect, snp_eff_what)

cds_snps <- cds_snps %>% 
  mutate(syn_v_nonsyn_codon_pos = ifelse(POS %in% HiMod$POS, "codon_pos1", "codon_pos3"))
```


## Repeat content around each SNP

I want to include at each SNP in the raster, some information about how much of the
sequence nearby is considered repeat sequence.  This might also be helpful in the future
for other species when we go to design amplicons for sequencing.

I am going to do this just by designating each base with a lowercase letter part of a repeat-masked
segment.  The strategy will be to pull out the sequence at every position, then
make a tibble and rollapply a window over it.  The we can join these onto the positions
used in each raster.

First, get chinook sequence in the region we are working with, which is from about 9.66 Mb to 14.83 Mb. 
```{sh}
samtools faidx genome/Otsh_v1.0_genomic.fna NC_037124.1:9660000-14830000 > intermediates/006/greb-ish-seq-chinook.fna

gzip -f intermediates/006/greb-ish-seq-chinook.fna
```

Now, read it into a tibble:
```{r}
dna_tibble <- read_lines("intermediates/006/greb-ish-seq-chinook.fna.gz")[-1] %>%
  paste(., collapse = "") %>%
  strsplit(., "") %>%
  .[[1]] %>%
  tibble(POS = seq(9660000, 14830000, by = 1),
         dna = .) %>%
  mutate(inRep = dna %in% c("a", "c", "g", "t"))

# now rollapply that dude in a 200 bp window centered on the current base
dna_repetitive_200 <- dna_tibble %>%
  mutate(rep_mean_200 = zoo::rollmean(inRep, 200, fill = NA, na.rm = TRUE))
```

## Positions of the RoSA markers and other SNPs

We will add dashed lines around the columns indicating the RoSA SNPs and also
the distal SNPs identified in @princeEvolutionaryBasisPremature2017.  We have
all those positions in the `data` directory.

```{r}
h_pos_for_paper <- read_tsv("data/assay-positions.tsv") %>%
  rename(name = Marker_name,
         POS = Position_on_Chr_28_in_Otsh_v1.0) %>%
  select(name, POS) %>%
  mutate(POS = as.integer(POS))

```

# Calculations to order haplotypes by number of spring-alleles in the RoSA

## Order haplos according to the number of spring alleles

```{r}
# focus on a smaller region
rosa2 <- big_haps2 %>%
  filter(POS > 12.05e6, POS < 12.5e06)
```

While we are here quickly deduce the RoSA genotype of the reference fish, by focusing
only on the SNPs from 12.26 to 12.29
```{r}
rosa2 %>% 
  filter(POS > 12.26e6, POS < 12.29e6) %>%
  group_by(POS, REF, ALT, spring_allele) %>% 
  tally() %>%
  select(-n) %>%
  mutate(spring_is_ref = REF == spring_allele) %>% 
  group_by(spring_is_ref) %>% 
  tally()
```

So, that is saying that the reference fish here has 68 spring alleles and 134 fall alleles
in the region from 12.26 to 12.29 Mb.  We can compare that to the distribution we see
in our fish later on when we are determining heterozygotes. 68 spring alleles puts it
solidly within what we expect for a fall run fish.


Order everyone by number of springer alleles in there:
```{r}
rosa2_sorted <- rosa2 %>%
  group_by(haplo_name) %>%
  mutate(sumS = sum(alle2 == "S")) %>%
  ungroup() %>% 
  arrange(desc(sumS), haplo_name, POS)
```

The above data frame has haplotypes ordered from "most springy in the RoSA" to "least springy in the RoSA."

## Define different orders for the haplotypes

We want to order haplotypes by ecotype, then lineage, then population
then by springyness.  We make one order that includes the Johnson Creek
fish, and then another one that does not (for the read depth raster).
```{r}
# first, order by ecotype, and then within that, spring-run-assoc alleles
htmp <-  rosa2_sorted %>% 
  mutate(hnames = haplo_name) %>%
  mutate(efact = factor(ecotype, levels = c("Spring", "Winter", "Late_Fall", "Fall"))) %>%
  arrange(efact, desc(sumS))

# then, order by ecotype, and within that, springy-ness of the full individual.
# this would put the two haplotypes within an individual next to one another
ht2 <- htmp %>%
  group_by(Indiv) %>%
  mutate(sumS_indiv = sum(sumS)) %>%
  ungroup() %>%
  arrange(efact, desc(sumS_indiv), Indiv, sumS)


# ht2 is not what we want, though.  So,
# here let us order by ecotype, and then lineage, then pop, and only then on springyness
ht3 <- ht2 %>%
  arrange(efact, desc(lineage), pop, desc(sumS), Indiv)

h_ord_eco_line_pop_springy <- unique(ht3$hnames)

# here is a hacky thing to make an ordering in which the Johnson Creek fish
# is in there between the spring and the winters
last_trin_spring <- max(which(str_detect(h_ord_eco_line_pop_springy, "Trinity_River_Hatchery_Spring")))

h_ord_eco_line_pop_springy_jc <- c(
  h_ord_eco_line_pop_springy[1:last_trin_spring],
  "Narum_et_al_Chinook_Assembly-a",
  h_ord_eco_line_pop_springy[-(1:last_trin_spring)]
)
```



# Prepare the tibbles for the row and column annotations

## Make the annotation columns tibble

This is just to get the lineage and the ecotype in a decent form:
```{r}
tmp <- c(1, 2, 3)
names(tmp) <- c("pop", "lineage", "ecotype")
annotation_columns <- rosa2_sorted %>%
  mutate(hnames = haplo_name) %>%
  select(hnames, lineage, ecotype, pop) %>%
  count(hnames, lineage, ecotype, pop) %>%
  select(-n) %>%
  gather(key = "column", value = "value", -hnames) %>%
  mutate(width = 0.015,
         order = tmp[column])

# now, I am going to add a label column which is what we want printed on each of these

```


## Make the row annotations tibble

I want to add to that a row at the bottom which says whether the "spring" allele is ancestral or derived or unknown (because there
is no Coho sequence at that point)
```{r}
ancy_row <- big_haps2 %>% 
  count(POS, spring_allele) %>%
  select(-n) %>%
  left_join(haps_fix %>% select(POS, AA), by = "POS") %>%
  mutate(value = ifelse(spring_allele == AA, "ancestral", "derived"),
         row = "spring_anc_or_derived",
         order = 3,
         height = 0.02)
```

I also want to have a row below the exon info that shows whether the snp is synonymous or missense.
```{r}
codon_row <- cds_snps %>%
  select(POS, syn_v_nonsyn_codon_pos) %>%
  rename(value = syn_v_nonsyn_codon_pos) %>%
  mutate(row = "codon_stuff",
         order = 2,
         height = 0.02)
```

So make a tibble with everything.  We can semi-join this thing for different
data sets.
```{r}
annotation_rows_full <- bind_rows(
  exon_stuff %>%
    ungroup() %>%
    select(POS, einc) %>%
    rename(value = einc) %>%
    mutate(row = "exon_stuff",
           order = 1,
           height = 0.02),
  codon_row,
  ancy_row
) %>%
  mutate(POS = as.integer(POS))
```


# Read in our color schemes and a few helper functions

```{r}
source("R/define_fcolors_all_sf.R")
source("R/function_prep_elements.R")
source("R/function_extra_labels.R")
```



# Now we are ready to make our plots

## Moderate zoom allelic-type haplo raster with Johnson Creek fish, hets not outlined in orange

```{r}
plist <- prep_elements(12.1e6, 12.6e6, 0.05e6, format = "%.2f", DSET = big_haps2_jc)

jca <- haplo_raster_plot(D = plist$D, 
                       h_ord = h_ord_eco_line_pop_springy_jc, 
                       pos_annot = plist$pos_annot, 
                       pos_bar_text_size = 8.0,
                       highlight_pos = h_pos_for_paper,
                       annotation_columns = annotation_columns,
                       annotation_rows = plist$ann_rows, 
                       fcolors = fcolors_all_sf, 
                       anno_row_start = 10,
                       snp_quant_tibble = plist$repcontent,
                       no_legend = TRUE, 
                       no_y_labels = TRUE, 
                       no_x_labels = TRUE)

jca2 <- extra_labels(g = jca, D = plist$D, h_ord = h_ord_eco_line_pop_springy_jc, 
                   xmids = plist$ac_x_midpoints, ymids = plist$ar_y_midpoints,
                   row_just = 0.5) +
  expand_limits(x = -130, y = 337)

# now, fill in the white space in the annotation columns with the gray color.
# this is totally a hard-wired hack!
jcy <- which(rev(h_ord_eco_line_pop_springy_jc) == "Narum_et_al_Chinook_Assembly-a")
jca3 <- jca2 +
  annotate("rect", xmin = -120, xmax = 0, ymin = jcy - 0.5, ymax = jcy + 0.5, colour = NA, fill = "darkgray")


ggsave(jca3, filename = "outputs/006/haplo-raster-alleles.pdf", width = 49, height = 30)

```


## Moderate Zoom read-depths, sorted by ecotype-lineage-pop-springy

We need to figure out the positions for the orange rectangle.  It should be from
12.311 to about 12.3215.  So, find the variant numbers associated with that. That
means we have to prep the elements now...
```{r}
plist <- prep_elements(12.1e6, 12.6e6, 0.05e6, format = "%.2f")

inner_variants <- tibble(POS = unique(plist$D$POS)) %>%
  ungroup() %>%
  mutate(idx = 1:n()) %>%
  filter(POS > 12.311e6, POS < 12.3215e6)

niv <- nrow(inner_variants)

# left and right points
left_x <- inner_variants$idx[1] - 2
right_x <- inner_variants$idx[niv] + 2

# top point is from about the 6th winter run haplotype
# bottom point is first fish
fish_ords <- tibble(fish = h_ord_eco_line_pop_springy) %>%
  mutate(idx = 1:n()) %>%
  mutate(winter_num = cumsum(str_detect(fish, "Winter")))

top_y <- nrow(fish_ords) - fish_ords$idx[fish_ords$winter_num == 5] + 1
bot_y <- nrow(fish_ords) - fish_ords$idx[nrow(fish_ords)] + 1

```

```{r}
g <- haplo_raster_plot(D = plist$D, 
                       h_ord = h_ord_eco_line_pop_springy, 
                       pos_annot = plist$pos_annot, 
                       pos_bar_text_size = 8.0,
                       highlight_pos = h_pos_for_paper,
                       annotation_columns = annotation_columns,
                       annotation_rows = plist$ann_rows, 
                       fcolors = fcolors_all_sf, 
                       anno_row_start = 10,
                       snp_quant_tibble = plist$repcontent,
                       plot_read_depths = TRUE,
                       no_y_labels = TRUE, 
                       no_x_labels = TRUE)

g2 <- extra_labels(g = g, D = plist$D, h_ord = h_ord_eco_line_pop_springy, 
                   xmids = plist$ac_x_midpoints, ymids = plist$ar_y_midpoints,
                   row_just = 0.5) +
  expand_limits(x = -130, y = 337) +
  theme(legend.key.width = unit(1.3, "in"),
        legend.key.height = unit(2, "in"),
        legend.text = element_text(size = 48.0),
        legend.title = element_text(size = 48.0)) +
  annotate("rect", xmin = left_x, xmax = right_x, ymin = bot_y, ymax = top_y, fill = NA, colour = "orange", alpha = 0.5, size = 4)

ggsave(g2, filename = "outputs/006/haplo-raster-read-depths.pdf", width = 49, height = 30)
```

# Session Info

```{r}
sessioninfo::session_info()
```

# Running Time

Running the code and rendering this notebook required approximately this much time
on a Mac laptop of middling speed:
```{r}
Sys.time() - start_time
```

# Citations


